For normalized numbers exp bits cant be all 0s or all 1s
Smallest normalized positive number (snpn) = 1
For |numbers| >= snpn & not infinity(exp bits = 111...1):
    Value = (-1)^S * M * 2^E 
      S  -> Sign (0 or 1)
      E  -> exp - bias 
        exp -> decimal value of exp bits 
        exp bits -> can never be 000...0 or 111...1
        bias = 2^(k-1) - 1, k = number of exp bits 

      E     -> -126 to 127 if k = 8
      Emin  -> -126 (exp bits = 000..1) 

      M  -> (1 + frac)
    frac -> decimal Value of frac bits (0 to 1 - e) [e->epsilon]
    1-e  -> value just less than 1
    frac bits -> 2^-1 2^-2 .... 2^-22 

Convert 5.5 to binary: 
    5 in binary:   101 
    0.5 in binary: 0.1 
    5.5  = 101.1 in base 2 
    S = 0

    Normalize to 1.xxx form:
        101.1 = 10.11 * 2 
              = 1.011 * 2^2

        E = 2
        M = 1.011 = 1 + 0.011 
        frac bits = 01100...0 
        frac = 0*2^-1 + 1*2^-2 + 1*2^-3
             = 0 + 0.25 + 0.125
             = 0.375 

    verify: 
        S = 0
        frac = 0.375 
        E = 2 
        
        Value = (-1)^0 * (1 + 0.375) * 2^2
              = 5.5

Convert 1.5 to binary:
    1 in binary:   1
    0.5 in binary: 0.1
    1.5 = 1.1 in base 2 
    S = 0

    Normalize to 1.xxx form:
        1.1 = 1.1 * 2^0 already in form 

        E = 0
        M = 1.1 = 1 + 0.1
        frac bits = 100...0
        frac = 1*2^-1
             = 0.5

    verify:
        S = 0
        frac = 0.5
        E = 0

        Value = (-1)^0 * (1 + 0.5) * 2^0
              = 1.5

For Denormalised values: (Form -> 0.xxx) 
    |values| -> 0 to 1 - e 

      M  = frac 
     exp bits -> 000...0 
     exp = 0
      E  = 1 - bias(= 127 if k = 8) 
         = 1 - 127 = -126 
         = Emin 
    Value = (-1)^S * M * 2^(Emin)


Binary rounding: 
    IEEE default: 
        Round to nearest 
        If halfway case, round to even LSB 

    Decimal:
        Round to nearest int:
        n = 2.5
        n is halfway between 2 & 3 
        round(n) = 2, since even 

        Round to nearest hundredth:
        1. n = 7.88500 
        round(n) = 7.88 
        Because:
            7.88500                       |   7.8 8|5 0 0
                ^                         |       ^
                halfway b/w 7.88 & 7.89   |       LSB = even, so to keep it even 
                                                        round down(i.e just truncate)

            7.88|500 <- truncate

        2. n = 7.87500
        round(n) = 7.88
        Because:
            7.87500                       |   7.8 7|5 0 0
                ^                         |       ^
                halfway b/w 7.87 & 7.88   |       LSB = odd, so round up to make it even 

            7.87500
          + 0.005
            --------
            7.88000

    Binary: 
        0 = even, 1 = odd 
        round up: truncate binary digits after LSB pos and +1 at LSB pos 
        round down: truncate b digits after LSB pos 

        if halfway: (i.e pattern = 100..0 after LSB pos)
            if LSB   = 0 (even) {round down}
            elif LSB = 1 (odd)  {roundn up} 

        Example:
        Round up to nearest quarter: (2 bit to the right of binary point)
        i.e { 
            if n = 1011.xxxx 
            - rounded n = 1011.xx 
            &
            - Diff b/w n and rounded n = 0.25 
        }

        1. let n = 10.00011 
        round(n) = 10.00 (rounded down)
        Because:
            10.00011
                    ^
                    011 is less than halfway

            10. 0 0 |0 1 1 <- truncate

        2. let n = 10.00110
        round(n) = 10.01 (rounded up)
        Because:
            10.00110
                    ^
                    11 is greater than halfway

            10.0 0 |1 1 0 <- truncate
            + 0.0 1
            -------
            10.0 1

        3. let n = 10.11100 
        round(n) = 11.00 
        Because:
            10.11|100                         |   10.1 1 1 0 0
                    ^                         |        ^
                    10..0 pattern = halfway   |        LSB = odd, so round up 

            10.1 1 |1 0 0 <- truncate
            + 0.0 1
            -------
            11.0 0

        4. let n = 10.10100 
        round(n) = 10.10 
        Because: 
            10.10|100                         |   10.1 0 1 0 0
                    ^                         |        ^
                    10..0 pattern = halfway   |        LSB = even, so round down

            10.1 0 |1 0 0 <- truncate
                     
                
               

                
                    
            
    